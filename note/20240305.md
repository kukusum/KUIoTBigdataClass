---
## 2024-03-05
---

- 다차원배열 (array of array)
    - int m[3][4];(3차원, 4차원...)
    - m배열 아래로 0, 1, 2 m[0], m[1], m[2]
    - m이라는 배열에 엘리먼트는 사이즈가 4인 인트형 배열??
    - 엘리먼트는 m[0][0]<-- 엘리먼트 배열 우측으로 0부터
    - ...
- 포인터 (pointer)
    - 포인터는 변수이다.
    - 포인터는 주소값 저장 용도로 쓰이는 변수이다.
    - 포인터상수는 주소값이다.
    - 포인터변수는 잘못된 뜻임(포인터자체가 변수임)
    - 포인터와 관련된 연산자
    - 포인터는 반드시 대상을 가르키고, (애스터리스크 연산)역참조 해야한다.
        - * asterisk(애스터리스크)
            - * 뒤에는 포인터가 온다.
            - 포인터가 가르키는 대상을 구해주세요
            - 다항연산

        - &(앰퍼샌드)
            - & 뒤에는 변수를 사용한다.
            - 변수의 시작 주소값을 구해주세요
            - 단항연산 
            - 왜 scanf 에서 변수의 주소값을 저장했을까?

    - int * (포인터) vs char * (포인터)
        - int a = 0x12345678; (16진수)
        - char *p;
        - p = &a; (&앞에 (char)입력 해줘야한다.)
        - printf("%?", *p);
            - 위값은 int형쓰면 12345678 char쓰면 12
            - int형 포인터는 int형자료 char형 포인터는 char형자료
            - 왜 포인트 앞에 타입을 쓰는지 이유...?

        - int a; 변수
        - int *p; 변수
        - a = 100; 상수
        - p = &a;
        - *p = 200; 변수
        - printf("%d\n", a);상수

        - 변수의 뜻
            - 프로그램의 시작과 끝에서 변하는 수
            - 메모리공간 추가로 필요
            - 할당된 공간의 주소값으로저장
        - 상수의 뜻
            - 프로그램 시작과 끝에서 변하지 않는 수
            - 메모리공간 필요 없음
            - ...?
    - 주소저장할때 용랑
        - 32 주소체계와 8 주소체계가 있음.
        - char 포인터는(32bit) 4바이트와 리눅스(64bit)는 8바이트

- 단일포인터
- 다중포인터
- 이중포인터 (단일포인터를 가르키는 용도로 사용한다.)
    - 단일포인터를 엘리먼트로 가지는 배열을 가르킬때 이중포인터를 사용한다.
        - int a;
        - int *pa;
        - int **ppa;
        - a = 100;
        - pa = &a;
        - ppa = &pa;
        - **ppa = 200;
        - printf("%d", a);
            
            - pp == &pa (int **)
            - *ppa == pa == &a (int *)
            - *(*ppa) == *pa == a (int)
            - 
            - 
- 삼중포인터
- ...백중포인터..

- 함수포인터
    - 함수를 가르킬때 사용한다..?
    
    int add(int a, int b)
    {
        return a + b;
    }
    
    int substract(int a, int b)
    {
        return a - b;

    }
        int (*fp)(int, int); // 함수포인터
        fp = &add;
        int re = (*fp)(4, 3); // 7
        fp = &substract;
        re = (*fp)(4, 3); // 1

- void* (보이드포인터)
    - 포괄형포인터 (generic point)
    - 순수하게 주소값을 저장하는 용도로 사용한다.
        - int a = 100;      double & = 3, 4;
        - void *p;          void *p;
        - p = &a;           p = &d;
    - 모든 주소값 타입을 다 받을수 있다.
    - 역참조 불가능하다.
    - 가르키는 대상의 포인트타입으로 타입캐스팅하고 역참조...?

- pointer & array

    - int nums[5] = {1, 2, 3, 4, 5};
    - int *p;
    - p = nums; (?)
    - 포인터와 배열의 관계
        1. 배열이름이 식에서 사용되면 첫번째 엘리먼트의 시작주소값을 의미한다
        2. 배열은 포인터식으로 포인터는 배열식으로 (반대도 가능)
            - . //한 주소당 4바이트씩 사용한다. (???)
            - . p = p + 1; == ++p;
        4. 포인터의 더하기1은 1바이트값을 더함?
        5. 포인터의 +1은 다음 엘리먼트를 가르킨다. ***

        6. char형 포인터 double형 포인터에 +1은 각각 값이 다름
        7. 포인터에 더하는 값은 배열에서 사용하는 INDEX !!
        8. +1은 주소값에 1을 더하는게 아니고 다음 엘리먼트
            
            int nums[5] = {1, 2, 3, 4, 5};
            int nums2[5];

            nums2 = nums; (x)
            &nums2[0] &nums[0] (x)

            for(i = 0; i < s; ++i>) {
                nums2[i] = nums[i];
            }
            
            ---
            int nums1[5] = {1, 2, 3, 4, 5};
            int nums2[5] = {1, 2, 3, 4, 5};
                if(nums1 = nums2) {
                    &nums[0] &nums2[0]
                }
                for(i = 0; i < 5; ++i>) {
                    if(nums[j] != nums[i])
                        break (?)
                }

               1. 포인터와 배열의 관계
                  
                    p == nums
                    p + 0 == &nums[0]
                    p + 1 == &nums[1]
                    p + 2 == &nums[2]
                    ...
                    p + i == &nums[i]
                    
                    *(p+0) == nums[0]
                    *(p+1) == nums[1]
                    ...
                    *(p+i) == nums[i]

                2. 배열은 포인터식으로, 포인터는 배열식으로
                
                    *(p+i) == nums[i]
                    
                    *(nums + i) == nums[i]
                    *(p+i) == p[i]

- 함수 (function)

    - 궁극적으로 반복되는 코드를 줄이기 위해서.
    - 프로시저 서브루틴 + 인자전달과 결과값이 추가된것을 함수라고한다.
    - 사용자 정의 연산(필요한 연산은 만들어서 사용한다)
    - (유저 디파인드 오퍼레이터)라이브러리함수
    - ex) power(2, 3) == 2^3, Factorial(5) == 5! ??

- 데니스리치의 그림..??
- 주소값 NULL 은 0이라는 의미, 아무것도 가르키지 않는다.
- 시스템 종류 Big-endian, Little-endian 으로 나뉜다.

